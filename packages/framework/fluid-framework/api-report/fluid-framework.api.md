## API Report File for "fluid-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BaseContainerRuntimeFactory } from '@fluidframework/aqueduct';
import { BaseSegment } from '@fluidframework/merge-tree';
import { Client } from '@fluidframework/merge-tree';
import { Deferred } from '@fluidframework/core-utils';
import { EventEmitter } from 'events';
import { FluidObject } from '@fluidframework/core-interfaces';
import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IChannelStorageService } from '@fluidframework/datastore-definitions';
import { IClient } from '@fluidframework/protocol-definitions';
import { IClientConfiguration } from '@fluidframework/protocol-definitions';
import { IClientDetails } from '@fluidframework/protocol-definitions';
import { ICombiningOp } from '@fluidframework/merge-tree';
import { IContainerRuntime } from '@fluidframework/container-runtime-definitions';
import { ICreateBlobResponse } from '@fluidframework/protocol-definitions';
import { IDisposable } from '@fluidframework/core-interfaces';
import { IDocumentMessage } from '@fluidframework/protocol-definitions';
import { IErrorBase } from '@fluidframework/core-interfaces';
import { IErrorEvent } from '@fluidframework/core-interfaces';
import { IEvent } from '@fluidframework/core-interfaces';
import { IEventProvider } from '@fluidframework/core-interfaces';
import { IEventThisPlaceHolder } from '@fluidframework/core-interfaces';
import { IFluidDataStoreFactory } from '@fluidframework/runtime-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidHandle } from '@fluidframework/core-interfaces';
import { IFluidLoadable } from '@fluidframework/core-interfaces';
import { IFluidRouter } from '@fluidframework/core-interfaces';
import { IFluidSerializer } from '@fluidframework/shared-object-base';
import { IJSONSegment } from '@fluidframework/merge-tree';
import { IMergeTreeDeltaCallbackArgs } from '@fluidframework/merge-tree';
import { IMergeTreeDeltaOpArgs } from '@fluidframework/merge-tree';
import { IMergeTreeGroupMsg } from '@fluidframework/merge-tree';
import { IMergeTreeInsertMsg } from '@fluidframework/merge-tree';
import { IMergeTreeMaintenanceCallbackArgs } from '@fluidframework/merge-tree';
import { IMergeTreeOp } from '@fluidframework/merge-tree';
import { IMergeTreeRemoveMsg } from '@fluidframework/merge-tree';
import { IQuorumClients } from '@fluidframework/protocol-definitions';
import { IRelativePosition } from '@fluidframework/merge-tree';
import { IRequest } from '@fluidframework/core-interfaces';
import { IResponse } from '@fluidframework/core-interfaces';
import { ISegment } from '@fluidframework/merge-tree';
import { ISegmentAction } from '@fluidframework/merge-tree';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISequencedProposal } from '@fluidframework/protocol-definitions';
import { ISharedObject } from '@fluidframework/shared-object-base';
import { ISharedObjectEvents } from '@fluidframework/shared-object-base';
import { ISignalMessage } from '@fluidframework/protocol-definitions';
import { ISnapshotTree } from '@fluidframework/protocol-definitions';
import { ISummaryContent } from '@fluidframework/protocol-definitions';
import { ISummaryHandle } from '@fluidframework/protocol-definitions';
import { ISummaryTree } from '@fluidframework/protocol-definitions';
import { ISummaryTreeWithStats } from '@fluidframework/runtime-definitions';
import { ITelemetryBaseLogger } from '@fluidframework/core-interfaces';
import { ITelemetryContext } from '@fluidframework/runtime-definitions';
import { ITokenClaims } from '@fluidframework/protocol-definitions';
import { IVersion } from '@fluidframework/protocol-definitions';
import { LocalReferencePosition } from '@fluidframework/merge-tree';
import { Marker } from '@fluidframework/merge-tree';
import { MergeTreeDeltaOperationType } from '@fluidframework/merge-tree';
import { MergeTreeDeltaOperationTypes } from '@fluidframework/merge-tree';
import { MergeTreeMaintenanceType } from '@fluidframework/merge-tree';
import { MergeTreeRevertibleDriver } from '@fluidframework/merge-tree';
import { MessageType } from '@fluidframework/protocol-definitions';
import { PropertiesManager } from '@fluidframework/merge-tree';
import { PropertySet } from '@fluidframework/merge-tree';
import { RangeStackMap } from '@fluidframework/merge-tree';
import { ReferencePosition } from '@fluidframework/merge-tree';
import { ReferenceType } from '@fluidframework/merge-tree';
import { Serializable } from '@fluidframework/datastore-definitions';
import { SharedObject } from '@fluidframework/shared-object-base';
import { SlidingPreference } from '@fluidframework/merge-tree';
import { SummarySerializer } from '@fluidframework/shared-object-base';
import { TextSegment } from '@fluidframework/merge-tree';
import { TypedEventEmitter } from '@fluid-internal/client-utils';

// @alpha
export enum AttachState {
    Attached = "Attached",
    Attaching = "Attaching",
    Detached = "Detached"
}

// @alpha
export namespace ConnectionState {
    export type CatchingUp = 1;
    export type Connected = 2;
    export type Disconnected = 0;
    export type EstablishingConnection = 3;
}

// @alpha
export type ConnectionState = ConnectionState.Disconnected | ConnectionState.EstablishingConnection | ConnectionState.CatchingUp | ConnectionState.Connected;

// @internal @deprecated
export enum ContainerErrorType {
    clientSessionExpiredError = "clientSessionExpiredError",
    dataCorruptionError = "dataCorruptionError",
    dataProcessingError = "dataProcessingError",
    genericError = "genericError",
    throttlingError = "throttlingError",
    usageError = "usageError"
}

// @internal
export interface ContainerSchema {
    dynamicObjectTypes?: LoadableObjectClass<any>[];
    initialObjects: LoadableObjectClassRecord;
}

// @alpha
export interface ContainerWarning extends IErrorBase {
    logged?: boolean;
}

// @internal (undocumented)
export function createDOProviderContainerRuntimeFactory(props: {
    schema: ContainerSchema;
}): IRuntimeFactory;

// @internal (undocumented)
export function createFluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema>(props: {
    container: IContainer;
    rootDataObject: IRootDataObject;
}): IFluidContainer<TContainerSchema>;

// @internal (undocumented)
export function createServiceAudience<M extends IMember = IMember>(props: {
    container: IContainer;
    createServiceMember: (audienceMember: IClient) => M;
}): IServiceAudience<M>;

// @internal
export type DataObjectClass<T extends IFluidLoadable> = {
    readonly factory: IFluidDataStoreFactory;
} & LoadableObjectCtor<T>;

// @internal (undocumented)
export type DeserializeCallback = (properties: PropertySet) => void;

// @internal @sealed
export class DirectoryFactory implements IChannelFactory {
    // (undocumented)
    static readonly Attributes: IChannelAttributes;
    // (undocumented)
    get attributes(): IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedDirectory;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, attributes: IChannelAttributes): Promise<ISharedDirectory>;
    // (undocumented)
    static readonly Type = "https://graph.microsoft.com/types/directory";
    // (undocumented)
    get type(): string;
}

// @internal @deprecated
export class DOProviderContainerRuntimeFactory extends BaseContainerRuntimeFactory {
    constructor(schema: ContainerSchema);
    // (undocumented)
    protected containerInitializingFirstTime(runtime: IContainerRuntime): Promise<void>;
}

// @alpha @deprecated
export enum DriverErrorType {
    authorizationError = "authorizationError",
    deltaStreamConnectionForbidden = "deltaStreamConnectionForbidden",
    fetchFailure = "fetchFailure",
    fetchTokenError = "fetchTokenError",
    fileIsLocked = "fileIsLocked",
    fileNotFoundOrAccessDeniedError = "fileNotFoundOrAccessDeniedError",
    fileOverwrittenInStorage = "fileOverwrittenInStorage",
    fluidInvalidSchema = "fluidInvalidSchema",
    genericError = "genericError",
    genericNetworkError = "genericNetworkError",
    incorrectServerResponse = "incorrectServerResponse",
    locationRedirection = "locationRedirection",
    offlineError = "offlineError",
    outOfStorageError = "outOfStorageError",
    throttlingError = "throttlingError",
    // (undocumented)
    unsupportedClientProtocolVersion = "unsupportedClientProtocolVersion",
    usageError = "usageError",
    writeError = "writeError"
}

// @internal
export const DriverErrorTypes: {
    readonly genericNetworkError: "genericNetworkError";
    readonly authorizationError: "authorizationError";
    readonly fileNotFoundOrAccessDeniedError: "fileNotFoundOrAccessDeniedError";
    readonly offlineError: "offlineError";
    readonly unsupportedClientProtocolVersion: "unsupportedClientProtocolVersion";
    readonly writeError: "writeError";
    readonly fetchFailure: "fetchFailure";
    readonly fetchTokenError: "fetchTokenError";
    readonly incorrectServerResponse: "incorrectServerResponse";
    readonly fileOverwrittenInStorage: "fileOverwrittenInStorage";
    readonly deltaStreamConnectionForbidden: "deltaStreamConnectionForbidden";
    readonly locationRedirection: "locationRedirection";
    readonly fluidInvalidSchema: "fluidInvalidSchema";
    readonly fileIsLocked: "fileIsLocked";
    readonly outOfStorageError: "outOfStorageError";
    readonly genericError: "genericError";
    readonly throttlingError: "throttlingError";
    readonly usageError: "usageError";
};

// @internal (undocumented)
export type DriverErrorTypes = (typeof DriverErrorTypes)[keyof typeof DriverErrorTypes];

// @alpha (undocumented)
export enum FetchSource {
    // (undocumented)
    default = "default",
    // (undocumented)
    noCache = "noCache"
}

// @alpha (undocumented)
export type FiveDaysMs = 432000000;

// @internal @deprecated
export class FluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema> extends TypedEventEmitter<IFluidContainerEvents> implements IFluidContainer<TContainerSchema> {
    constructor(container: IContainer, rootDataObject: IRootDataObject);
    attach(): Promise<string>;
    get attachState(): AttachState;
    connect(): Promise<void>;
    get connectionState(): ConnectionState;
    create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
    disconnect(): Promise<void>;
    dispose(): void;
    get disposed(): boolean;
    get initialObjects(): InitialObjects<TContainerSchema>;
    readonly INTERNAL_CONTAINER_DO_NOT_USE?: () => IContainer;
    get isDirty(): boolean;
}

// @internal
export function getTextAndMarkers(sharedString: SharedString, label: string, start?: number, end?: number): {
    parallelText: string[];
    parallelMarkers: Marker[];
};

// @alpha
export interface IAnyDriverError extends Omit<IDriverErrorBase, "errorType"> {
    // (undocumented)
    readonly errorType: string;
}

// @alpha
export interface IAudience extends EventEmitter {
    getMember(clientId: string): IClient | undefined;
    getMembers(): Map<string, IClient>;
    on(event: "addMember" | "removeMember", listener: (clientId: string, client: IClient) => void): this;
}

// @alpha
export interface IBatchMessage {
    // (undocumented)
    compression?: string;
    // (undocumented)
    contents?: string;
    // (undocumented)
    metadata: Record<string, unknown> | undefined;
    // (undocumented)
    referenceSequenceNumber?: number;
}

// @internal
export interface IConnection {
    id: string;
    mode: "write" | "read";
}

// @alpha
export interface IConnectionDetails {
    checkpointSequenceNumber: number | undefined;
    // (undocumented)
    claims: ITokenClaims;
    // (undocumented)
    clientId: string;
    // (undocumented)
    serviceConfiguration: IClientConfiguration;
}

// @alpha
export interface IContainer extends IEventProvider<IContainerEvents>, IFluidRouter {
    attach(request: IRequest, attachProps?: {
        deltaConnection?: "none" | "delayed";
    }): Promise<void>;
    readonly attachState: AttachState;
    readonly audience: IAudience;
    readonly clientId?: string | undefined;
    close(error?: ICriticalContainerError): void;
    readonly closed: boolean;
    connect(): void;
    readonly connectionState: ConnectionState;
    deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    disconnect(): void;
    dispose(error?: ICriticalContainerError): void;
    readonly disposed?: boolean;
    forceReadonly?(readonly: boolean): any;
    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;
    getEntryPoint(): Promise<FluidObject | undefined>;
    getLoadedCodeDetails(): IFluidCodeDetails | undefined;
    getQuorum(): IQuorumClients;
    getSpecifiedCodeDetails(): IFluidCodeDetails | undefined;
    // @deprecated (undocumented)
    readonly IFluidRouter: IFluidRouter;
    readonly isDirty: boolean;
    proposeCodeDetails(codeDetails: IFluidCodeDetails): Promise<boolean>;
    readonly readOnlyInfo: ReadOnlyInfo;
    // @deprecated (undocumented)
    request(request: {
        url: "/";
        headers?: undefined;
    }): Promise<IResponse>;
    // @deprecated
    request(request: IRequest): Promise<IResponse>;
    resolvedUrl: IResolvedUrl | undefined;
    serialize(): string;
}

// @alpha
export interface IContainerContext {
    readonly attachState: AttachState;
    // (undocumented)
    readonly audience: IAudience | undefined;
    // (undocumented)
    readonly baseSnapshot: ISnapshotTree | undefined;
    // (undocumented)
    readonly clientDetails: IClientDetails;
    // (undocumented)
    readonly clientId: string | undefined;
    // (undocumented)
    readonly closeFn: (error?: ICriticalContainerError) => void;
    // (undocumented)
    readonly connected: boolean;
    // (undocumented)
    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;
    // (undocumented)
    readonly disposeFn?: (error?: ICriticalContainerError) => void;
    getAbsoluteUrl?(relativeUrl: string): Promise<string | undefined>;
    // (undocumented)
    getLoadedFromVersion(): IVersion | undefined;
    // @deprecated (undocumented)
    getSpecifiedCodeDetails?(): IFluidCodeDetails | undefined;
    // @deprecated
    readonly id: string;
    // (undocumented)
    readonly loader: ILoader;
    // (undocumented)
    readonly options: ILoaderOptions;
    // (undocumented)
    pendingLocalState?: unknown;
    // (undocumented)
    readonly quorum: IQuorumClients;
    readonly scope: FluidObject;
    // (undocumented)
    readonly storage: IDocumentStorageService;
    // (undocumented)
    readonly submitBatchFn: (batch: IBatchMessage[], referenceSequenceNumber?: number) => number;
    // @deprecated (undocumented)
    readonly submitFn: (type: MessageType, contents: any, batch: boolean, appData?: any) => number;
    // (undocumented)
    readonly submitSignalFn: (contents: any, targetClientId?: string) => void;
    // (undocumented)
    readonly submitSummaryFn: (summaryOp: ISummaryContent, referenceSequenceNumber?: number) => number;
    // (undocumented)
    readonly supportedFeatures?: ReadonlyMap<string, unknown>;
    // (undocumented)
    readonly taggedLogger: ITelemetryBaseLogger;
    // (undocumented)
    updateDirtyContainerState(dirty: boolean): void;
}

// @alpha
export interface IContainerEvents extends IEvent {
    (event: "readonly", listener: (readonly: boolean) => void): void;
    (event: "connected", listener: (clientId: string) => void): any;
    (event: "codeDetailsProposed", listener: (codeDetails: IFluidCodeDetails, proposal: ISequencedProposal) => void): any;
    (event: "disconnected", listener: () => void): any;
    (event: "attaching", listener: () => void): any;
    (event: "attached", listener: () => void): any;
    (event: "closed", listener: (error?: ICriticalContainerError) => void): any;
    (event: "disposed", listener: (error?: ICriticalContainerError) => void): any;
    (event: "warning", listener: (error: ContainerWarning) => void): any;
    (event: "op", listener: (message: ISequencedDocumentMessage) => void): any;
    (event: "dirty", listener: (dirty: boolean) => void): any;
    (event: "saved", listener: (dirty: boolean) => void): any;
}

// @internal
export interface ICreateInfo {
    ccIds: string[];
    csn: number;
}

// @alpha
export type ICriticalContainerError = IErrorBase;

// @alpha
export interface IDeltaManager<T, U> extends IEventProvider<IDeltaManagerEvents>, IDeltaSender {
    readonly active: boolean;
    readonly clientDetails: IClientDetails;
    readonly hasCheckpointSequenceNumber: boolean;
    readonly inbound: IDeltaQueue<T>;
    readonly inboundSignal: IDeltaQueue<ISignalMessage>;
    readonly initialSequenceNumber: number;
    readonly lastKnownSeqNumber: number;
    readonly lastMessage: ISequencedDocumentMessage | undefined;
    readonly lastSequenceNumber: number;
    readonly maxMessageSize: number;
    readonly minimumSequenceNumber: number;
    readonly outbound: IDeltaQueue<U[]>;
    // (undocumented)
    readonly readOnlyInfo: ReadOnlyInfo;
    readonly serviceConfiguration: IClientConfiguration | undefined;
    submitSignal(content: any, targetClientId?: string): void;
    readonly version: string;
}

// @alpha
export interface IDeltaManagerEvents extends IEvent {
    // @deprecated (undocumented)
    (event: "prepareSend", listener: (messageBuffer: any[]) => void): any;
    // @deprecated (undocumented)
    (event: "submitOp", listener: (message: IDocumentMessage) => void): any;
    (event: "op", listener: (message: ISequencedDocumentMessage, processingTime: number) => void): any;
    (event: "pong", listener: (latency: number) => void): any;
    (event: "connect", listener: (details: IConnectionDetails, opsBehind?: number) => void): any;
    (event: "disconnect", listener: (reason: string, error?: IAnyDriverError) => void): any;
    (event: "readonly", listener: (readonly: boolean, readonlyConnectionReason?: {
        reason: string;
        error?: IErrorBase;
    }) => void): any;
}

// @alpha
export interface IDeltaQueue<T> extends IEventProvider<IDeltaQueueEvents<T>>, IDisposable {
    idle: boolean;
    length: number;
    pause(): Promise<void>;
    paused: boolean;
    peek(): T | undefined;
    resume(): void;
    toArray(): T[];
    waitTillProcessingDone(): Promise<{
        count: number;
        duration: number;
    }>;
}

// @alpha
export interface IDeltaQueueEvents<T> extends IErrorEvent {
    (event: "push", listener: (task: T) => void): any;
    (event: "op", listener: (task: T) => void): any;
    (event: "idle", listener: (count: number, duration: number) => void): any;
}

// @alpha
export interface IDeltaSender {
    flush(): void;
}

// @internal
export interface IDirectory extends Map<string, any>, IEventProvider<IDirectoryEvents>, Partial<IDisposable> {
    readonly absolutePath: string;
    countSubDirectory?(): number;
    createSubDirectory(subdirName: string): IDirectory;
    deleteSubDirectory(subdirName: string): boolean;
    get<T = any>(key: string): T | undefined;
    getSubDirectory(subdirName: string): IDirectory | undefined;
    getWorkingDirectory(relativePath: string): IDirectory | undefined;
    hasSubDirectory(subdirName: string): boolean;
    set<T = unknown>(key: string, value: T): this;
    subdirectories(): IterableIterator<[string, IDirectory]>;
}

// @internal
export interface IDirectoryClearOperation {
    path: string;
    type: "clear";
}

// @internal
export interface IDirectoryCreateSubDirectoryOperation {
    path: string;
    subdirName: string;
    type: "createSubDirectory";
}

// @internal
export interface IDirectoryDataObject {
    ci?: ICreateInfo;
    storage?: {
        [key: string]: ISerializableValue;
    };
    subdirectories?: {
        [subdirName: string]: IDirectoryDataObject;
    };
}

// @internal
export interface IDirectoryDeleteOperation {
    key: string;
    path: string;
    type: "delete";
}

// @internal
export interface IDirectoryDeleteSubDirectoryOperation {
    path: string;
    subdirName: string;
    type: "deleteSubDirectory";
}

// @internal
export interface IDirectoryEvents extends IEvent {
    (event: "containedValueChanged", listener: (changed: IValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryCreated", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryDeleted", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "disposed", listener: (target: IEventThisPlaceHolder) => void): any;
    (event: "undisposed", listener: (target: IEventThisPlaceHolder) => void): any;
}

// @internal
export type IDirectoryKeyOperation = IDirectorySetOperation | IDirectoryDeleteOperation;

// @internal
export interface IDirectoryNewStorageFormat {
    blobs: string[];
    content: IDirectoryDataObject;
}

// @internal
export type IDirectoryOperation = IDirectoryStorageOperation | IDirectorySubDirectoryOperation;

// @internal
export interface IDirectorySetOperation {
    key: string;
    path: string;
    type: "set";
    value: ISerializableValue;
}

// @internal
export type IDirectoryStorageOperation = IDirectoryKeyOperation | IDirectoryClearOperation;

// @internal
export type IDirectorySubDirectoryOperation = IDirectoryCreateSubDirectoryOperation | IDirectoryDeleteSubDirectoryOperation;

// @internal
export interface IDirectoryValueChanged extends IValueChanged {
    path: string;
}

// @alpha
export interface IDocumentStorageService extends Partial<IDisposable> {
    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;
    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;
    getSnapshotTree(version?: IVersion, scenarioName?: string): Promise<ISnapshotTree | null>;
    getVersions(versionId: string | null, count: number, scenarioName?: string, fetchSource?: FetchSource): Promise<IVersion[]>;
    readonly policies?: IDocumentStorageServicePolicies;
    readBlob(id: string): Promise<ArrayBufferLike>;
    // (undocumented)
    repositoryUrl: string;
    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;
}

// @alpha
export interface IDocumentStorageServicePolicies {
    readonly caching?: LoaderCachingPolicy;
    readonly maximumCacheDurationMs?: FiveDaysMs;
}

// @alpha
export interface IDriverErrorBase {
    canRetry: boolean;
    endpointReached?: boolean;
    readonly errorType: DriverErrorType;
    readonly message: string;
    online?: string;
}

// @alpha
export interface IFluidCodeDetails {
    readonly config?: IFluidCodeDetailsConfig;
    readonly package: string | Readonly<IFluidPackage>;
}

// @alpha
export interface IFluidCodeDetailsConfig {
    // (undocumented)
    readonly [key: string]: string;
}

// @internal
export interface IFluidContainer<TContainerSchema extends ContainerSchema = ContainerSchema> extends IEventProvider<IFluidContainerEvents> {
    attach(): Promise<string>;
    readonly attachState: AttachState;
    connect(): void;
    readonly connectionState: ConnectionState;
    create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
    disconnect(): void;
    dispose(): void;
    readonly disposed: boolean;
    readonly initialObjects: InitialObjects<TContainerSchema>;
    readonly isDirty: boolean;
}

// @internal
export interface IFluidContainerEvents extends IEvent {
    (event: "connected", listener: () => void): void;
    (event: "disconnected", listener: () => void): void;
    (event: "saved", listener: () => void): void;
    (event: "dirty", listener: () => void): void;
    (event: "disposed", listener: (error?: ICriticalContainerError) => void): any;
}

// @alpha
export interface IFluidPackage {
    [key: string]: unknown;
    fluid: {
        [environment: string]: undefined | IFluidPackageEnvironment;
    };
    name: string;
}

// @alpha
export interface IFluidPackageEnvironment {
    [target: string]: undefined | {
        files: string[];
        [key: string]: unknown;
    };
}

// @alpha
export interface IGetPendingLocalStateProps {
    readonly notifyImminentClosure: boolean;
    readonly stopBlobAttachingSignal?: AbortSignal;
}

// @internal
export interface IInterval {
    // (undocumented)
    clone(): IInterval;
    compare(b: IInterval): number;
    compareEnd(b: IInterval): number;
    compareStart(b: IInterval): number;
    modify(label: string, start: SequencePlace | undefined, end: SequencePlace | undefined, op?: ISequencedDocumentMessage, localSeq?: number, useNewSlidingBehavior?: boolean): IInterval | undefined;
    // (undocumented)
    overlaps(b: IInterval): boolean;
    union(b: IInterval): IInterval;
}

// @internal
export interface IIntervalCollection<TInterval extends ISerializableInterval> extends TypedEventEmitter<IIntervalCollectionEvent<TInterval>> {
    // (undocumented)
    [Symbol.iterator](): Iterator<TInterval>;
    // @deprecated
    add(start: SequencePlace, end: SequencePlace, intervalType: IntervalType, props?: PropertySet): TInterval;
    add({ start, end, props, }: {
        start: SequencePlace;
        end: SequencePlace;
        props?: PropertySet;
    }): TInterval;
    // (undocumented)
    attachDeserializer(onDeserialize: DeserializeCallback): void;
    // (undocumented)
    readonly attached: boolean;
    attachIndex(index: IntervalIndex<TInterval>): void;
    change(id: string, start: SequencePlace, end: SequencePlace): TInterval | undefined;
    changeProperties(id: string, props: PropertySet): any;
    // (undocumented)
    CreateBackwardIteratorWithEndPosition(endPosition: number): Iterator<TInterval>;
    // (undocumented)
    CreateBackwardIteratorWithStartPosition(startPosition: number): Iterator<TInterval>;
    // (undocumented)
    CreateForwardIteratorWithEndPosition(endPosition: number): Iterator<TInterval>;
    // (undocumented)
    CreateForwardIteratorWithStartPosition(startPosition: number): Iterator<TInterval>;
    detachIndex(index: IntervalIndex<TInterval>): boolean;
    // @deprecated (undocumented)
    findOverlappingIntervals(startPosition: number, endPosition: number): TInterval[];
    gatherIterationResults(results: TInterval[], iteratesForward: boolean, start?: number, end?: number): void;
    // (undocumented)
    getIntervalById(id: string): TInterval | undefined;
    map(fn: (interval: TInterval) => void): void;
    // @deprecated (undocumented)
    nextInterval(pos: number): TInterval | undefined;
    // @deprecated (undocumented)
    previousInterval(pos: number): TInterval | undefined;
    removeIntervalById(id: string): TInterval | undefined;
}

// @internal
export interface IIntervalCollectionEvent<TInterval extends ISerializableInterval> extends IEvent {
    (event: "changeInterval", listener: (interval: TInterval, previousInterval: TInterval, local: boolean, op: ISequencedDocumentMessage | undefined, slide: boolean) => void): any;
    (event: "addInterval" | "deleteInterval", listener: (interval: TInterval, local: boolean, op: ISequencedDocumentMessage | undefined) => void): any;
    (event: "propertyChanged", listener: (interval: TInterval, propertyDeltas: PropertySet, local: boolean, op: ISequencedDocumentMessage | undefined) => void): any;
}

// @internal @sealed @deprecated (undocumented)
export interface IIntervalHelpers<TInterval extends ISerializableInterval> {
    // (undocumented)
    create(label: string, start: SequencePlace | undefined, end: SequencePlace | undefined, client: Client | undefined, intervalType: IntervalType, op?: ISequencedDocumentMessage, fromSnapshot?: boolean, useNewSlidingBehavior?: boolean): TInterval;
}

// @internal @deprecated (undocumented)
export interface IJSONRunSegment<T> extends IJSONSegment {
    // (undocumented)
    items: Serializable<T>[];
}

// @alpha
export interface ILoader extends Partial<IProvideLoader> {
    // @deprecated (undocumented)
    readonly IFluidRouter: IFluidRouter;
    // @deprecated (undocumented)
    request(request: IRequest): Promise<IResponse>;
    resolve(request: IRequest, pendingLocalState?: string): Promise<IContainer>;
}

// @alpha (undocumented)
export type ILoaderOptions = {
    [key in string | number]: any;
} & {
    cache?: boolean;
    provideScopeLoader?: boolean;
    maxClientLeaveWaitTime?: number;
};

// @internal
export interface ILocalValue {
    makeSerialized(serializer: IFluidSerializer, bind: IFluidHandle): ISerializedValue;
    readonly type: string;
    readonly value: any;
}

// @internal (undocumented)
export interface IMapMessageLocalMetadata {
    // (undocumented)
    localSeq: number;
}

// @internal
export interface IMember {
    connections: IConnection[];
    userId: string;
}

// @internal
export type InitialObjects<T extends ContainerSchema> = {
    [K in keyof T["initialObjects"]]: T["initialObjects"][K] extends LoadableObjectClass<infer TChannel> ? TChannel : never;
};

// @internal
export interface InteriorSequencePlace {
    // (undocumented)
    pos: number;
    // (undocumented)
    side: Side;
}

// @internal
export class Interval implements ISerializableInterval {
    constructor(start: number, end: number, props?: PropertySet);
    // (undocumented)
    addProperties(newProps: PropertySet, collaborating?: boolean, seq?: number, op?: ICombiningOp): PropertySet | undefined;
    addPropertySet(props: PropertySet): void;
    // (undocumented)
    auxProps: PropertySet[] | undefined;
    // (undocumented)
    clone(): Interval;
    compare(b: Interval): number;
    compareEnd(b: Interval): number;
    compareStart(b: Interval): number;
    // (undocumented)
    end: number;
    // (undocumented)
    getAdditionalPropertySets(): PropertySet[];
    getIntervalId(): string;
    // (undocumented)
    getProperties(): PropertySet;
    modify(label: string, start?: SequencePlace, end?: SequencePlace, op?: ISequencedDocumentMessage): Interval | undefined;
    // (undocumented)
    overlaps(b: Interval): boolean;
    properties: PropertySet;
    // (undocumented)
    propertyManager: PropertiesManager;
    // (undocumented)
    serialize(): ISerializedInterval;
    // (undocumented)
    start: number;
    union(b: Interval): Interval;
}

// @internal
export interface IntervalIndex<TInterval extends ISerializableInterval> {
    add(interval: TInterval): void;
    remove(interval: TInterval): void;
}

// @internal
export interface IntervalLocator {
    interval: SequenceInterval;
    label: string;
}

// @internal
export function intervalLocatorFromEndpoint(potentialEndpoint: LocalReferencePosition): IntervalLocator | undefined;

// @internal
export const IntervalOpType: {
    readonly ADD: "add";
    readonly DELETE: "delete";
    readonly CHANGE: "change";
    readonly PROPERTY_CHANGED: "propertyChanged";
    readonly POSITION_REMOVE: "positionRemove";
};

// @internal (undocumented)
export type IntervalOpType = (typeof IntervalOpType)[keyof typeof IntervalOpType];

// @internal
export const IntervalStickiness: {
    readonly NONE: 0;
    readonly START: 1;
    readonly END: 2;
    readonly FULL: 3;
};

// @internal
export type IntervalStickiness = (typeof IntervalStickiness)[keyof typeof IntervalStickiness];

// @internal (undocumented)
export enum IntervalType {
    // @deprecated (undocumented)
    Nest = 1,
    // (undocumented)
    Simple = 0,
    SlideOnRemove = 2,
    Transient = 4
}

// @alpha (undocumented)
export interface IProvideLoader {
    // (undocumented)
    readonly ILoader: ILoader;
}

// @internal (undocumented)
export interface IProvideRootDataObject {
    // (undocumented)
    readonly IRootDataObject?: IRootDataObject;
}

// @alpha (undocumented)
export interface IProvideRuntimeFactory {
    // (undocumented)
    readonly IRuntimeFactory: IRuntimeFactory;
}

// @alpha (undocumented)
export interface IResolvedUrl {
    // (undocumented)
    endpoints: {
        [name: string]: string;
    };
    id: string;
    // (undocumented)
    tokens: {
        [name: string]: string;
    };
    // (undocumented)
    type: "fluid";
    // (undocumented)
    url: string;
}

// @internal
export interface IRootDataObject extends IProvideRootDataObject {
    create<T extends IFluidLoadable>(objectClass: LoadableObjectClass<T>): Promise<T>;
    readonly initialObjects: LoadableObjectRecord;
}

// @alpha
export interface IRuntime extends IDisposable {
    createSummary(blobRedirectTable?: Map<string, string>): ISummaryTree;
    getEntryPoint(): Promise<FluidObject | undefined>;
    getPendingLocalState(props?: IGetPendingLocalStateProps): unknown;
    // @deprecated
    notifyAttaching(snapshot: ISnapshotTreeWithBlobContents): void;
    notifyOpReplay?(message: ISequencedDocumentMessage): Promise<void>;
    process(message: ISequencedDocumentMessage, local: boolean): any;
    processSignal(message: any, local: boolean): any;
    // @deprecated
    request(request: IRequest): Promise<IResponse>;
    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;
    setConnectionState(connected: boolean, clientId?: string): any;
}

// @alpha (undocumented)
export const IRuntimeFactory: keyof IProvideRuntimeFactory;

// @alpha
export interface IRuntimeFactory extends IProvideRuntimeFactory {
    instantiateRuntime(context: IContainerContext, existing: boolean): Promise<IRuntime>;
}

// @internal
export interface ISequenceDeltaRange<TOperation extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationTypes> {
    operation: TOperation;
    position: number;
    propertyDeltas: PropertySet;
    segment: ISegment;
}

// @internal (undocumented)
export interface ISerializableInterval extends IInterval {
    // (undocumented)
    addProperties(props: PropertySet, collaborating?: boolean, seq?: number): PropertySet | undefined;
    getIntervalId(): string | undefined;
    properties: PropertySet;
    // (undocumented)
    propertyManager: PropertiesManager;
    // (undocumented)
    serialize(): ISerializedInterval;
}

// @internal @deprecated
export interface ISerializableValue {
    type: string;
    value: any;
}

// @internal
export interface ISerializedInterval {
    end: number | "start" | "end";
    // (undocumented)
    endSide?: Side;
    intervalType: IntervalType;
    properties?: PropertySet;
    sequenceNumber: number;
    start: number | "start" | "end";
    // (undocumented)
    startSide?: Side;
    stickiness?: IntervalStickiness;
}

// @internal
export interface ISerializedValue {
    type: string;
    value: string | undefined;
}

// @internal
export interface IServiceAudience<M extends IMember> extends IEventProvider<IServiceAudienceEvents<M>> {
    getMembers(): Map<string, M>;
    getMyself(): Myself<M> | undefined;
}

// @internal
export interface IServiceAudienceEvents<M extends IMember> extends IEvent {
    // @eventProperty
    (event: "membersChanged", listener: () => void): void;
    // @eventProperty
    (event: "memberAdded", listener: MemberChangedListener<M>): void;
    // @eventProperty
    (event: "memberRemoved", listener: MemberChangedListener<M>): void;
}

// @internal
export interface ISharedDirectory extends ISharedObject<ISharedDirectoryEvents & IDirectoryEvents>, Omit<IDirectory, "on" | "once" | "off"> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<[string, any]>;
    // (undocumented)
    readonly [Symbol.toStringTag]: string;
}

// @internal
export interface ISharedDirectoryEvents extends ISharedObjectEvents {
    (event: "valueChanged", listener: (changed: IDirectoryValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "clear", listener: (local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryCreated", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "subDirectoryDeleted", listener: (path: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
}

// @internal (undocumented)
export interface ISharedIntervalCollection<TInterval extends ISerializableInterval> {
    // (undocumented)
    getIntervalCollection(label: string): IIntervalCollection<TInterval>;
}

// @internal
export interface ISharedMap extends ISharedObject<ISharedMapEvents>, Map<string, any> {
    get<T = any>(key: string): T | undefined;
    set<T = unknown>(key: string, value: T): this;
}

// @internal
export interface ISharedMapEvents extends ISharedObjectEvents {
    (event: "valueChanged", listener: (changed: IValueChanged, local: boolean, target: IEventThisPlaceHolder) => void): any;
    (event: "clear", listener: (local: boolean, target: IEventThisPlaceHolder) => void): any;
}

// @internal
export interface ISharedSegmentSequenceEvents extends ISharedObjectEvents {
    // (undocumented)
    (event: "createIntervalCollection", listener: (label: string, local: boolean, target: IEventThisPlaceHolder) => void): any;
    // (undocumented)
    (event: "sequenceDelta", listener: (event: SequenceDeltaEvent, target: IEventThisPlaceHolder) => void): any;
    // (undocumented)
    (event: "maintenance", listener: (event: SequenceMaintenanceEvent, target: IEventThisPlaceHolder) => void): any;
}

// @internal
export interface ISharedString extends SharedSegmentSequence<SharedStringSegment> {
    insertMarker(pos: number, refType: ReferenceType, props?: PropertySet): IMergeTreeInsertMsg | undefined;
    insertText(pos: number, text: string, props?: PropertySet): void;
    posFromRelativePos(relativePos: IRelativePosition): number;
}

// @alpha
export interface ISnapshotTreeWithBlobContents extends ISnapshotTree {
    // (undocumented)
    blobsContents: {
        [path: string]: ArrayBufferLike;
    };
    // (undocumented)
    trees: {
        [path: string]: ISnapshotTreeWithBlobContents;
    };
}

// @alpha
export interface ISummaryContext {
    readonly ackHandle: string | undefined;
    readonly proposalHandle: string | undefined;
    // (undocumented)
    readonly referenceSequenceNumber: number;
}

// @internal
export interface IValueChanged {
    key: string;
    previousValue: any;
}

// @internal @deprecated
export interface IValueOpEmitter {
    // @deprecated
    emit(opName: IntervalOpType, previousValue: undefined, params: SerializedIntervalDelta, localOpMetadata: IMapMessageLocalMetadata): void;
}

// @internal
export type LoadableObjectClass<T extends IFluidLoadable> = DataObjectClass<T> | SharedObjectClass<T>;

// @internal
export type LoadableObjectClassRecord = Record<string, LoadableObjectClass<any>>;

// @internal
export type LoadableObjectCtor<T extends IFluidLoadable> = new (...args: any[]) => T;

// @internal
export type LoadableObjectRecord = Record<string, IFluidLoadable>;

// @alpha (undocumented)
export enum LoaderCachingPolicy {
    NoCaching = 0,
    Prefetch = 1
}

// @internal
export class LocalValueMaker {
    constructor(serializer: IFluidSerializer);
    fromInMemory(value: unknown): ILocalValue;
    fromSerializable(serializable: ISerializableValue): ILocalValue;
}

// @internal @sealed
export class MapFactory implements IChannelFactory {
    // (undocumented)
    static readonly Attributes: IChannelAttributes;
    // (undocumented)
    get attributes(): IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): ISharedMap;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, attributes: IChannelAttributes): Promise<ISharedMap>;
    // (undocumented)
    static readonly Type = "https://graph.microsoft.com/types/map";
    // (undocumented)
    get type(): string;
}

// @internal
export type MemberChangedListener<M extends IMember> = (clientId: string, member: M) => void;

// @internal
export type Myself<M extends IMember = IMember> = M & {
    currentConnection: string;
};

// @alpha (undocumented)
export type ReadOnlyInfo = {
    readonly readonly: false | undefined;
} | {
    readonly readonly: true;
    readonly forced: boolean;
    readonly permissions: boolean | undefined;
    readonly storageOnly: boolean;
    readonly storageOnlyReason?: string;
};

// @internal
export class SequenceDeltaEvent extends SequenceEvent<MergeTreeDeltaOperationType> {
    constructor(opArgs: IMergeTreeDeltaOpArgs, deltaArgs: IMergeTreeDeltaCallbackArgs, mergeTreeClient: Client);
    readonly isLocal: boolean;
    // (undocumented)
    readonly opArgs: IMergeTreeDeltaOpArgs;
}

// @internal
export abstract class SequenceEvent<TOperation extends MergeTreeDeltaOperationTypes = MergeTreeDeltaOperationTypes> {
    constructor(deltaArgs: IMergeTreeDeltaCallbackArgs<TOperation>, mergeTreeClient: Client);
    get clientId(): string | undefined;
    // (undocumented)
    readonly deltaArgs: IMergeTreeDeltaCallbackArgs<TOperation>;
    // (undocumented)
    readonly deltaOperation: TOperation;
    get first(): Readonly<ISequenceDeltaRange<TOperation>>;
    get last(): Readonly<ISequenceDeltaRange<TOperation>>;
    get ranges(): readonly Readonly<ISequenceDeltaRange<TOperation>>[];
}

// @internal
export class SequenceInterval implements ISerializableInterval {
    constructor(client: Client,
    start: LocalReferencePosition,
    end: LocalReferencePosition, intervalType: IntervalType, props?: PropertySet, startSide?: Side, endSide?: Side);
    addPositionChangeListeners(beforePositionChange: () => void, afterPositionChange: () => void): void;
    // (undocumented)
    addProperties(newProps: PropertySet, collab?: boolean, seq?: number, op?: ICombiningOp): PropertySet | undefined;
    // (undocumented)
    clone(): SequenceInterval;
    compare(b: SequenceInterval): number;
    compareEnd(b: SequenceInterval): number;
    compareStart(b: SequenceInterval): number;
    end: LocalReferencePosition;
    // (undocumented)
    readonly endSide: Side;
    getIntervalId(): string;
    // (undocumented)
    intervalType: IntervalType;
    modify(label: string, start: SequencePlace | undefined, end: SequencePlace | undefined, op?: ISequencedDocumentMessage, localSeq?: number, useNewSlidingBehavior?: boolean): SequenceInterval;
    // (undocumented)
    overlaps(b: SequenceInterval): boolean;
    // (undocumented)
    overlapsPos(bstart: number, bend: number): boolean;
    properties: PropertySet;
    // (undocumented)
    propertyManager: PropertiesManager;
    removePositionChangeListeners(): void;
    // (undocumented)
    serialize(): ISerializedInterval;
    start: LocalReferencePosition;
    // (undocumented)
    readonly startSide: Side;
    // (undocumented)
    get stickiness(): IntervalStickiness;
    union(b: SequenceInterval): SequenceInterval;
}

// @internal
export class SequenceMaintenanceEvent extends SequenceEvent<MergeTreeMaintenanceType> {
    constructor(opArgs: IMergeTreeDeltaOpArgs | undefined, deltaArgs: IMergeTreeMaintenanceCallbackArgs, mergeTreeClient: Client);
    // (undocumented)
    readonly opArgs: IMergeTreeDeltaOpArgs | undefined;
}

// @internal
export type SequencePlace = number | "start" | "end" | InteriorSequencePlace;

// @internal
export type SerializedIntervalDelta = Omit<ISerializedInterval, "start" | "end" | "properties"> & Partial<Pick<ISerializedInterval, "start" | "end" | "properties">>;

// @internal @deprecated
export abstract class ServiceAudience<M extends IMember = IMember> extends TypedEventEmitter<IServiceAudienceEvents<M>> implements IServiceAudience<M> {
    constructor(
    container: IContainer);
    protected readonly audience: IAudience;
    protected readonly container: IContainer;
    protected abstract createServiceMember(audienceMember: IClient): M;
    getMembers(): Map<string, M>;
    getMyself(): Myself<M> | undefined;
    protected lastMembers: Map<string, M>;
    protected shouldIncludeAsMember(member: IClient): boolean;
}

// @internal @sealed
export class SharedDirectory extends SharedObject<ISharedDirectoryEvents> implements ISharedDirectory {
    [Symbol.iterator](): IterableIterator<[string, any]>;
    [Symbol.toStringTag]: string;
    constructor(id: string, runtime: IFluidDataStoreRuntime, attributes: IChannelAttributes);
    get absolutePath(): string;
    // (undocumented)
    protected applyStashedOp(op: unknown): unknown;
    clear(): void;
    countSubDirectory(): number;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedDirectory;
    createSubDirectory(subdirName: string): IDirectory;
    delete(key: string): boolean;
    deleteSubDirectory(subdirName: string): boolean;
    // (undocumented)
    dispose(error?: Error): void;
    // (undocumented)
    get disposed(): boolean;
    entries(): IterableIterator<[string, any]>;
    forEach(callback: (value: any, key: string, map: Map<string, any>) => void): void;
    get<T = any>(key: string): T | undefined;
    static getFactory(): IChannelFactory;
    getSubDirectory(subdirName: string): IDirectory | undefined;
    getWorkingDirectory(relativePath: string): IDirectory | undefined;
    has(key: string): boolean;
    hasSubDirectory(subdirName: string): boolean;
    keys(): IterableIterator<string>;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // (undocumented)
    readonly localValueMaker: LocalValueMaker;
    // (undocumented)
    protected onDisconnect(): void;
    protected populate(data: IDirectoryDataObject): void;
    // (undocumented)
    protected processCore(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    protected reSubmitCore(content: unknown, localOpMetadata: unknown): void;
    // (undocumented)
    protected rollback(content: unknown, localOpMetadata: unknown): void;
    set<T = unknown>(key: string, value: T): this;
    get size(): number;
    subdirectories(): IterableIterator<[string, IDirectory]>;
    submitDirectoryMessage(op: IDirectoryOperation, localOpMetadata: unknown): void;
    // (undocumented)
    protected summarizeCore(serializer: IFluidSerializer, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    values(): IterableIterator<any>;
}

// @internal @deprecated (undocumented)
export class SharedIntervalCollection extends SharedObject implements ISharedIntervalCollection<Interval> {
    // (undocumented)
    readonly [Symbol.toStringTag]: string;
    constructor(id: string, runtime: IFluidDataStoreRuntime, attributes: IChannelAttributes);
    // (undocumented)
    protected applyStashedOp(): void;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedIntervalCollection;
    static getFactory(): IChannelFactory;
    // (undocumented)
    getIntervalCollection(label: string): IIntervalCollection<Interval>;
    protected getIntervalCollectionPath(label: string): string;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // (undocumented)
    protected onDisconnect(): void;
    // (undocumented)
    protected processCore(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    protected reSubmitCore(content: any, localOpMetadata: unknown): void;
    // (undocumented)
    protected summarizeCore(serializer: IFluidSerializer): ISummaryTreeWithStats;
}

// @internal @deprecated
export class SharedIntervalCollectionFactory implements IChannelFactory {
    // (undocumented)
    static readonly Attributes: IChannelAttributes;
    // (undocumented)
    get attributes(): IChannelAttributes;
    // (undocumented)
    create(runtime: IFluidDataStoreRuntime, id: string): SharedIntervalCollection;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, attributes: IChannelAttributes): Promise<SharedIntervalCollection>;
    // (undocumented)
    static readonly Type = "https://graph.microsoft.com/types/sharedIntervalCollection";
    // (undocumented)
    get type(): string;
}

// @internal
export class SharedMap extends SharedObject<ISharedMapEvents> implements ISharedMap {
    [Symbol.iterator](): IterableIterator<[string, any]>;
    readonly [Symbol.toStringTag]: string;
    constructor(id: string, runtime: IFluidDataStoreRuntime, attributes: IChannelAttributes);
    // (undocumented)
    protected applyStashedOp(content: unknown): unknown;
    clear(): void;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedMap;
    delete(key: string): boolean;
    entries(): IterableIterator<[string, any]>;
    forEach(callbackFn: (value: any, key: string, map: Map<string, any>) => void): void;
    get<T = any>(key: string): T | undefined;
    static getFactory(): IChannelFactory;
    has(key: string): boolean;
    keys(): IterableIterator<string>;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // (undocumented)
    protected onDisconnect(): void;
    // (undocumented)
    protected processCore(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    // (undocumented)
    protected reSubmitCore(content: unknown, localOpMetadata: unknown): void;
    // (undocumented)
    protected rollback(content: unknown, localOpMetadata: unknown): void;
    set(key: string, value: unknown): this;
    get size(): number;
    // (undocumented)
    protected summarizeCore(serializer: IFluidSerializer, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    values(): IterableIterator<any>;
}

// @internal
export type SharedObjectClass<T extends IFluidLoadable> = {
    readonly getFactory: () => IChannelFactory;
} & LoadableObjectCtor<T>;

// @internal (undocumented)
export abstract class SharedSegmentSequence<T extends ISegment> extends SharedObject<ISharedSegmentSequenceEvents> implements ISharedIntervalCollection<SequenceInterval>, MergeTreeRevertibleDriver {
    constructor(dataStoreRuntime: IFluidDataStoreRuntime, id: string, attributes: IChannelAttributes, segmentFromSpec: (spec: IJSONSegment) => ISegment);
    annotateRange(start: number, end: number, props: PropertySet, combiningOp?: ICombiningOp): void;
    // (undocumented)
    protected applyStashedOp(content: any): unknown;
    // (undocumented)
    protected client: Client;
    createLocalReferencePosition(segment: T, offset: number, refType: ReferenceType, properties: PropertySet | undefined, slidingPreference?: SlidingPreference, canSlideToEndpoint?: boolean): LocalReferencePosition;
    // (undocumented)
    protected didAttach(): void;
    getContainingSegment(pos: number): {
        segment: T | undefined;
        offset: number | undefined;
    };
    // (undocumented)
    getCurrentSeq(): number;
    getIntervalCollection(label: string): IIntervalCollection<SequenceInterval>;
    // (undocumented)
    getIntervalCollectionLabels(): IterableIterator<string>;
    getLength(): number;
    getPosition(segment: ISegment): number;
    // (undocumented)
    getPropertiesAtPosition(pos: number): PropertySet | undefined;
    // (undocumented)
    getRangeExtentsOfPosition(pos: number): {
        posStart: number | undefined;
        posAfterEnd: number | undefined;
    };
    // @deprecated (undocumented)
    getStackContext(startPos: number, rangeLabels: string[]): RangeStackMap;
    // @deprecated (undocumented)
    groupOperation(groupOp: IMergeTreeGroupMsg): void;
    protected guardReentrancy: <TRet>(callback: () => TRet) => TRet;
    // (undocumented)
    id: string;
    // (undocumented)
    protected initializeLocalCore(): void;
    insertAtReferencePosition(pos: ReferencePosition, segment: T): void;
    insertFromSpec(pos: number, spec: IJSONSegment): void;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // (undocumented)
    get loaded(): Promise<void>;
    protected loadedDeferred: Deferred<void>;
    localReferencePositionToPosition(lref: ReferencePosition): number;
    // (undocumented)
    protected onConnect(): void;
    // (undocumented)
    protected onDisconnect(): void;
    posFromRelativePos(relativePos: IRelativePosition): number;
    // (undocumented)
    protected processCore(message: ISequencedDocumentMessage, local: boolean, localOpMetadata: unknown): void;
    protected processGCDataCore(serializer: SummarySerializer): void;
    removeLocalReferencePosition(lref: LocalReferencePosition): LocalReferencePosition | undefined;
    // (undocumented)
    removeRange(start: number, end: number): IMergeTreeRemoveMsg;
    protected replaceRange(start: number, end: number, segment: ISegment): void;
    resolveRemoteClientPosition(remoteClientPosition: number, remoteClientRefSeq: number, remoteClientId: string): number | undefined;
    // (undocumented)
    protected reSubmitCore(content: any, localOpMetadata: unknown): void;
    // (undocumented)
    readonly segmentFromSpec: (spec: IJSONSegment) => ISegment;
    // @deprecated (undocumented)
    submitSequenceMessage(message: IMergeTreeOp): void;
    // (undocumented)
    protected summarizeCore(serializer: IFluidSerializer, telemetryContext?: ITelemetryContext): ISummaryTreeWithStats;
    walkSegments<TClientData>(handler: ISegmentAction<TClientData>, start?: number, end?: number, accum?: TClientData, splitRange?: boolean): void;
}

// @internal @deprecated (undocumented)
export class SharedSequence<T> extends SharedSegmentSequence<SubSequence<T>> {
    constructor(document: IFluidDataStoreRuntime, id: string, attributes: IChannelAttributes, specToSegment: (spec: IJSONSegment) => ISegment);
    getItemCount(): number;
    getItems(start: number, end?: number): Serializable<T>[];
    // (undocumented)
    id: string;
    // (undocumented)
    insert(pos: number, items: Serializable<T>[], props?: PropertySet): void;
    // (undocumented)
    remove(start: number, end: number): void;
}

// @internal
export class SharedString extends SharedSegmentSequence<SharedStringSegment> implements ISharedString {
    constructor(document: IFluidDataStoreRuntime, id: string, attributes: IChannelAttributes);
    annotateMarker(marker: Marker, props: PropertySet, combiningOp?: ICombiningOp): void;
    // @deprecated
    annotateMarkerNotifyConsensus(marker: Marker, props: PropertySet, callback: (m: Marker) => void): void;
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedString;
    // @deprecated
    findTile(startPos: number | undefined, tileLabel: string, preceding?: boolean): {
        tile: ReferencePosition;
        pos: number;
    } | undefined;
    static getFactory(): SharedStringFactory;
    getMarkerFromId(id: string): ISegment | undefined;
    getText(start?: number, end?: number): string;
    // (undocumented)
    getTextRangeWithMarkers(start: number, end: number): string;
    getTextWithPlaceholders(start?: number, end?: number): string;
    // (undocumented)
    id: string;
    insertMarker(pos: number, refType: ReferenceType, props?: PropertySet): IMergeTreeInsertMsg | undefined;
    insertMarkerRelative(relativePos1: IRelativePosition, refType: ReferenceType, props?: PropertySet): void;
    insertText(pos: number, text: string, props?: PropertySet): void;
    insertTextRelative(relativePos1: IRelativePosition, text: string, props?: PropertySet): void;
    // (undocumented)
    get ISharedString(): ISharedString;
    removeText(start: number, end: number): IMergeTreeRemoveMsg;
    replaceText(start: number, end: number, text: string, props?: PropertySet): void;
    protected rollback(content: any, localOpMetadata: unknown): void;
    searchForMarker(startPos: number, markerLabel: string, forwards?: boolean): Marker | undefined;
}

// @internal (undocumented)
export class SharedStringFactory implements IChannelFactory {
    // (undocumented)
    static readonly Attributes: IChannelAttributes;
    // (undocumented)
    get attributes(): IChannelAttributes;
    // (undocumented)
    create(document: IFluidDataStoreRuntime, id: string): SharedString;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, attributes: IChannelAttributes): Promise<SharedString>;
    // (undocumented)
    static segmentFromSpec(spec: any): SharedStringSegment;
    // (undocumented)
    static Type: string;
    // (undocumented)
    get type(): string;
}

// @internal (undocumented)
export type SharedStringSegment = TextSegment | Marker;

// @internal
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// @internal @deprecated (undocumented)
export class SubSequence<T> extends BaseSegment {
    constructor(items: Serializable<T>[]);
    // (undocumented)
    append(segment: ISegment): void;
    // (undocumented)
    canAppend(segment: ISegment): boolean;
    // (undocumented)
    clone(start?: number, end?: number): SubSequence<T>;
    // (undocumented)
    protected createSplitSegmentAt(pos: number): SubSequence<T> | undefined;
    // (undocumented)
    static fromJSONObject<U>(spec: Serializable): SubSequence<U> | undefined;
    // (undocumented)
    static is(segment: ISegment): segment is SubSequence<any>;
    // (undocumented)
    items: Serializable<T>[];
    // (undocumented)
    removeRange(start: number, end: number): boolean;
    // (undocumented)
    toJSONObject(): IJSONRunSegment<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type: string;
    // (undocumented)
    static readonly typeString: string;
}

```
